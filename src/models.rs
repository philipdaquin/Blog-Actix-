//  Interacting with the database 

use crate::errors::AppError; 

//  We are bringing the users item from the autogenerated SCHEMA to be used to the users database table
use crate::schema::{users};

use crate::schema::posts; 
//  We import posts from the generated schema 

//  We are accessing the database from Diesel 
use diesel::prelude::*; 

use crate::schema::comments; 

//  We are defining our own Result type aliased for Result in the standard library 
type Result<T> = std::result::Result<T, AppError>;

//  Introuducing a struct that represents one post row in the database 
#[derive(Queryable, Associations, Identifiable, Serialize, Debug)]
#[belongs_to(User)]
//  Declaring the Associations between two records requires the belongs_to attribute on the child and specifies the name of the struct that represents the parent 
//  The belongs_to attribute accepts a foreign_key argument if the relevant foreign key is different from the 'table_name_id'
pub struct Post { 
    pub id: i32, 
    pub user_id: i32, 
    pub title: String, 
    pub body: String, 
    pub published: bool, 
}

//  **We need a Rust Struct to represent a user in the database. We create the struct just like any other
#[derive(Queryable, Identifiable, Serialize, Debug, PartialEq)]
//  Queryable allow us to automatically get a User struct from queries of the users table
//  Identifiable trait allows us to sign a primary key to a primary value 

pub struct User {
    pub id: i32, 
    pub username: String,
}
#[derive(Queryable, Identifiable, Associations, Serialize, Debug,)]
#[belongs_to(User)]
#[belongs_to(Post)]
pub struct Comment { 
    pub id: i32,
    pub user_id: i32, 
    pub post_id: i32,
    pub body: String, 
}
//  **Create user
pub fn create_user(conn: &SqliteConnection, username: &str) -> Result<User> {   
    //  PARAMETERS: sqliteconnection, username string => Returns either a User or an error 
    //  This function does not have to worry about where to get a database connection it simply assumes one and this let's us then interact with the database   
    //  sqlite does not support getting the ide of just inserted row as part of the insert statement    
    //  We have to do another query to actually get the data back out to build a USER struct 
    
    conn.transaction(|| {      
        
        //  CONNECTION type SUPPORTS a method Transaction which takes a CLOSURE => This RETURNS a RESULT
        //  if RESULT = Error, then the transaction is rolled back and the error result is returned 
        //  if Ok variant => The transaction is commited and the successful result is returned 

        diesel::insert_into(users::table)
        //  Inserting a user with the supplied username into the users table 
        //  Imported users item from the schema has an item for for TABLE as a whole 
            .values((users::username.eq(username), ))
        
            .execute(conn)?;
            //  Execute method on the query builder returns a RESULT with the error being the Diesel specific error type
            //  We can the ? operator and return a Result with our AppError error type because of our FROM implementations in our errors module 

        users::table    
        //  Fetching a single user from the database.. 

            .order(users::id.desc())
            //  We create a query where we order by descennding ID to get the most recently inserted row

            .select((users::id, users::username))
            //  We specify the SELECT method what columns we want in a tuple ie. (ID and USERNAME)

            .first(conn)
            //  This tells Diesel to do a LIMIT 1 and expect a single result => the RESULT returns being the RESULTING RECORD or a NOT FOUND ERROR 
            
            .map_err(Into::into)   
            //  WE can't use the '?' operator here to result our RESULT, we have to explicity concert the Diesel error type to our AppError to match the function signature 
            //  Rust doesn't do this conversion, so we have to use the mapp.Err
            //  We can use INTO here because we implemented FROM and INTO gets implemented automatically 
    }) 
}

//  **Fetching a User 
pub enum UserKey<'a> {
    Username(&'a str),
    ID(i32), 
}

// Getting the user 
pub fn find_user<'a>(conn: &SqliteConnection, key: UserKey<'a>) -> Result<User> { 
    match key { 
    //  If we have a username then we do a filter by username equal to the value passed in
    //  ID, then can use the special FIND function which attempts to find a single record based on the primary key for that table
        UserKey::Username(name) => users::table
            .filter(users::username.eq(name))
            .select((users::id, users::username))
            .first::<User>(conn)
            .map_err(AppError::from), 
        
            UserKey::ID(id) => users::table
            .find(id)
            .select((users::id, users::username))
            .first::<User>(conn)
            .map_err(Into::into), 
    }
}

//  Creating a Post 
//  WE require a User object here which is a matter of choice. 
//  By default we set the post to be unpublished based on our schema, so we don't take the a published parameter
pub fn create_post(conn: &SqliteConnection, user: &User, title: &str, body: &str) -> Result<Post> { 
    conn.transaction(|| { 
        diesel::insert_into(posts::table)
            .values((
                posts::user_id.eq(user.id),
                posts::title.eq(title),
                posts::body.eq(body), 
            ))  
            .execute(conn)?; 
        
        posts::table
            .order(posts::id.desc())
            .select(posts::all_columns)
            //  This is shorthand that Diesel provides so that we do not have to write out tuple with each column explicity listed 

            .first(conn)
            .map_err(Into::into)
    })

}

//  Publishing a post
//  The 'create method' uses the database default for the published column and therefore in order to set published to true we need to update the database 
//  row for a particular post
pub fn publish_post(conn: &SqliteConnection, post_id: i32) -> Result<Post> {
    //  We are only updating a single column so we pass one expression to set the method, but if you want to update multiple columns you can pass a tuple to set instead 
    conn.transaction(|| { 
        diesel::update(posts::table.filter(posts::id.eq(post_id)))
            .set(posts::published.eq(true))
            .execute(conn)?;
    posts::table    
            .find(post_id)
            .select(posts::all_columns)
            .first(conn)
            .map_err(Into::into)
    }) 
}

//  Retrieve Posts
pub fn all_posts(conn: &SqliteConnection) -> Result<Vec<((Post, User), Vec<(Comment, User)>)>> {
//  The return type of this function is a list of tuples where the first element is a post and the second element is the author 
    let query = posts::table 
        .order(posts::id.desc())
        //  We order the posts based on their ide as this will make them newest first 

        .filter(posts::published.eq(true))
        //  We are only selecting that have been published 
        
        .inner_join(users::table)
        //  We want to fetch all of the data about the post as well as data about the author
        //  We use the inner_join to with the users table 
        .select((posts::all_columns, (users::id, users::username)));
        //  WE are selecting the two elements both of which are tuples representing the columns we want to fetch 
    let posts_with_user = query.load::<(Post, User)>(conn)?;
        //  We then tell load the type to coerce these columns into and Diesel Takes care of the rest
    let (posts, post_users): (Vec<_>, Vec<_>) = posts_with_user.into_iter().unzip();

    let comments = Comment::belonging_to(&posts)
        .inner_join(users::table)
        .select((comments::all_columns, (users::id, users::username)))
        .load::<(Comment, User)>(conn)? 
        .grouped_by(&posts); 

    Ok(posts.into_iter().zip(post_users).zip(comments).collect())

}

//  We are going to retrieve posts authored by a particular user
//  user_id is choses which will just result in an empty set of posts if the user does not exist 
//  SInce the author is the same for all of these posts, we only return a vector of posts rather than the tuple 
pub fn user_posts(conn: &SqliteConnection, user_id: i32) -> Result<Vec<(Post, Vec<(Comment, User)>)>> { 
    let posts = posts::table
        .filter(posts::user_id.eq(user_id))
        .order(posts::id.desc())
        .select(posts::all_columns)
        .load::<Post>(conn)?;
    let comments = Comment::belonging_to(&posts)
        .inner_join(users::table)
        .select((comments::all_columns, (users::id, users::username)))
        .load::<(Comment, User)>(conn)?
        .grouped_by(&posts);
        
    Ok(posts.into_iter().zip(comments).collect())
}

//  Creating A Comment 
//  User_id and Post_id 
pub fn create_comment(conn: &SqliteConnection, user_id: i32, post_id: i32, body: &str) -> Result<Comment> {
    conn.transaction(|| { 
        diesel::insert_into(comments::table)    
            .values((
                comments::user_id.eq(user_id), 
                comments::post_id.eq(post_id), 
                comments::body.eq(body), 
            ))
            .execute(conn)?; 
        comments::table 
            .order(comments::id.desc())
            .select(comments::all_columns)
            .first(conn)
            .map_err(Into::into)    
    }) 
}
//  Getting Comments on A Post
pub fn post_comments(conn: &SqliteConnection, post_id: i32) -> Result<Vec<(Comment, User)>> { 
    comments::table
        .filter(comments::post_id.eq(post_id))
        .inner_join(users::table)
        .select((comments::all_columns, (users::id, users::username)))
        .load::<(Comment, User)>(conn)
        .map_err(Into::into)
}

//  Fetching all comments by a user 
//  We want to Fetch the post for each comment, but we don't want all of them
//  Instead, We'll create a new struct to represent a subset of the post data that we want to fetch alongside each comment
#[derive(Queryable, Serialize, Debug)]
pub struct PostWithComment { 
    pub id: i32,
    pub title: String, 
    pub published: bool, 
}

pub fn user_comments(conn: &SqliteConnection, user_id: i32) -> Result<Vec<(Comment, PostWithComment)>> { 
    comments::table 
        .filter(comments::user_id.eq(user_id))
        .inner_join(posts::table)
        .select((
            comments::all_columns,
            (posts::id, posts::title, posts::published),
        ))
        .load::<(Comment, PostWithComment)>(conn)
        .map_err(Into::into)
}
//  We filter based on the passed in user_id and then join with the posts data to get the extra information about the posts
//  We use the select method to narrow down which columns from the posts table we need to construct our PostWithComment Struct and 
//  then load a tuple with results in getting the return type we want which is a vector of tuples where each element is a commnet and some data about that post the comment is on 